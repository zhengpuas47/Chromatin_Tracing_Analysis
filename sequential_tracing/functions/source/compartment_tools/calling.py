import numpy as np
from scipy.spatial import ConvexHull
from scipy.spatial.distance import pdist, cdist, squareform
from scipy.stats import linregress
## Compartment Analysis
#-----------------------------------------------------------------------------------
# part 1: population averaged compartment calling
def compartment_calling():
    pass

def calculate_scaling(distmap, region_starts, selected_regions=None, 
                      positive_scaling=True, verbose=True):
    """Function to calculate scaling factor for given distance map and region start genomic coordinates
    Inputs:
        distmap: nxn distance matrix for hi-c or median distance, 
            positive for median and negative for hic, np.ndarray of nxn
        region_starts: starting genomic coorinates of corresponding regions, array-like of n ints
        positive_scaling: whether the scaling for 'distance' to genomic-distance is positive or negative,
            positive for median distances, negative for Hi-C
        verbose: say something! bool
    Outputs:
        _lr: scipy.stats.linregress object containing all information for scaling
        _norm_mat: normalization matrix generated by linear regression
        """
    ## check inputs
    _distmap = np.array(distmap).copy()
    if verbose:
        print(f"-- start calculate region scaling to genomic distance with", end=' ')
    if len(np.shape(_distmap)) != 2:
        raise ValueError(
            f"Wrong input shape for _distmap, should be 2d but {np.shape(_distmap)} is given")
    if selected_regions is not None and len(selected_regions) != len(_distmap):
        raise IndexError(f"shape of selected_regions:{len(selected_regions)} not match with shape of distmap:{len(_distmap)}")
    if selected_regions is None:
        _sel = np.arange(len(_distmap))
    else:
        _sel = np.array(selected_regions, dtype=np.int)
    # region starts
    _regions = np.array(region_starts)
    if len(_regions.shape) == 2:
        if np.array(_regions.shape)[0] == np.array(_regions.shape)[1]:
            _reg_mat = _regions
        else:
            _reg_mat = squareform(pdist(_regions))
    elif len(_regions.shape) == 1:
        _reg_mat = squareform(pdist(_regions[:,np.newaxis]))
    else:
        raise IndexError(f"Wrong input shape for region_starts: {np.shape(_regions)}")
    # check shape
    if len(_reg_mat) != len(_distmap):
        raise IndexError(f"shape of regions:{len(_reg_mat)} not match with shape of distmap:{len(_distmap)}")
    ## unravel
    _dists = np.ravel(np.triu(_distmap[_sel][:,_sel],1))
    _reg_dists = np.ravel(np.triu(_reg_mat[_sel][:,_sel], 1))
    # keep non-zeros
    _keep = (np.isnan(_dists) == False) * (np.isnan(_reg_dists) == False) \
            * (_dists > 0) * (_reg_dists > 0) 
    _dists = _dists[_keep]
    _reg_dists = _reg_dists[_keep]
    # linear regression
    if positive_scaling:
        _lr = linregress(np.log(_reg_dists), np.log(_dists))
        _norm_mat = np.exp(np.log(_reg_mat) * _lr.slope + _lr.intercept)
    else:
        _lr = linregress(np.log(_reg_dists), -np.log(_dists))
        _norm_mat = np.exp(- np.log(_reg_mat) * _lr.slope - _lr.intercept)
    print(_lr) 
    for _i in range(len(_norm_mat)):
        if positive_scaling:
            _norm_mat[_i,_i] = np.exp(_lr.intercept)
        else:
            _norm_mat[_i,_i] = np.exp(-_lr.intercept)
    
    return _lr, _norm_mat
#-----------------------------------------------------------------------------------

# basic function to determine if a point is in convex hull or not
def is_in_hull(ref_zxys, zxy, remove_vertices=True):
    """Check if point zxy in ref_zxys
    either zxy or ref_zxys should be 3d ZXY coordinates"""
    if len(np.shape(zxy)) != 1:
        raise ValueError(f"Wrong input dimension for p, should be 1d")

    # Remove Nan in ref_zxys
    ref_zxys = np.array(ref_zxys) # convert to array
    _kept_rows = np.isnan(ref_zxys).sum(axis=1) == 0
    # remove itself
    if remove_vertices:
        for _i, _ref_zxy in enumerate(ref_zxys):
            if (_ref_zxy == np.array(zxy)).all():
                _kept_rows[_i] = False
    # apply remove
    _kept_ref_zxys = ref_zxys[_kept_rows]
    if len(_kept_ref_zxys) <= 3:
        print('Not enough points to create convex hull.')
        return False
    # create hull for ref_zxys
    _hull = ConvexHull(_kept_ref_zxys)
    # create hull for ref_zxys + zxy
    _extend_zxys = np.concatenate([_kept_ref_zxys, zxy[np.newaxis,:]])
    _extend_hull = ConvexHull(np.array(_extend_zxys))
    if list(_hull.vertices) == list(_extend_hull.vertices):
        return True
    else:
        return False

# basic function to wrap is_in_hull to do bootstrap
def _bootstrap_region_in_domain(_dm_zxys, _reg_zxy, 
                                _sampling_indices=None, 
                                _sampling_size=None, 
                                _n_iter=100, _remove_self=True):
    ## check inputs
    if np.isnan(_reg_zxy).any():
        return np.nan
    _dm_zxys = np.array(_dm_zxys)
    # determine if _reg_zxy is within _dm_zxys
    self_id = -1
    if _remove_self:
        for _i, _zxy in enumerate(_dm_zxys):
            if (_zxy == np.array(_reg_zxy)).all():
                self_id = _i
                break
    # if sampling indices directly given, do a modification
    if _sampling_indices is not None:
        _n_iter = len(_sampling_indices)
        _sampling_indices = np.array(_sampling_indices, dtype=np.int)
    # else do the sampling de novo
    else:
        if _sampling_size is None:
            raise ValueError(f"_sampling_size should be given if no sampling indices directly provided.")
        if _remove_self and self_id >= 0:
            _sampling_indices = [np.random.choice(len(_dm_zxys)-1, _sampling_size, replace=False)
                                 for _i in range(_n_iter)]
        else:
            _sampling_indices = [np.random.choice(len(_dm_zxys)-1, _sampling_size, replace=False)
                                 for _i in range(_n_iter)]
        _sampling_indices = np.array(_sampling_indices, dtype=np.int)
    # adjust sampling if shouldn't include self point
    if _remove_self and self_id >= 0:
        _sampling_indices[_sampling_indices>=self_id] += 1

    ## do sampling
    _p = [is_in_hull(_dm_zxys[_inds], _reg_zxy, remove_vertices=_remove_self)
          for _inds in _sampling_indices]

    return np.nanmean(_p)